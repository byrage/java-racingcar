- 객체단위로 테스트를 하기 때문에 equals(), hashCode()가 자연스럽게 필요하게 된다.
- 모든 값을 테스트 할 필요 없다. 경계값만 테스트하면 된다. ex) move 일때는 4와 5
- 테스트에 의존하자. 우연에 의한 프로그래밍과는 반대되는 시각
- 객체지향의 장점 : 테스트 용이, 로직 중복 제거
- 한 개의 primitive 필드를 클래스로 분리하고 해당 클래스에서 가지고 있는 상태로 할수 있는 행위를 고민해보자.
  * 객체로 감싸야지만 객체간의 연관관계, 밸리데이션, 분명한 의미 부여가 가능하다.
  * Position 객체가 직접 move한다. 현실세계와 전혀 다르게 객체가 자신의 행위를 결정한다.
  * 외부에서는 primitive 타입으로 통신할수있지만, 객체 내부에서는 감싼 객체로 통신
  * 클래스 내에서 한개의 필드로 일어나는 행위의 비율이 높을수록 응집도가 높은 것
  * 클래스 내의 여러 메소드 네이밍에 클래스와 관계 없는 공통적인 단어가 있다면, 분리의 근거가 된다고 봐도 될듯
- 같은 List<Car> 이더라도, Cars와 Winners로 일급 컬렉션을 나누면 어떤일을 하는지 쉽게 파악이 가능
- 테스트를 모두 다 짜야겠다는 강박을 버리자. 불안한 부분에만 테스트를 작성하자
